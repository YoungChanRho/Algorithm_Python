# 1210_Ladder1
# 220811
'''
점심 시간에 산책을 다니는 사원들은 최근 날씨가 더워져, 사다리 게임을 통하여 누가 아이스크림을 구입할지 결정하기로 한다.
김 대리는 사다리타기에 참여하지 않는 대신 사다리를 그리기로 하였다.
사다리를 다 그리고 보니 김 대리는 어느 사다리를 고르면 X표시에 도착하게 되는지 궁금해졌다. 이를 구해보자.
아래 <그림 1>의 예를 살펴보면, 출발점 x=0 및 x=9인 세로 방향의 두 막대 사이에 임의의 개수의 막대들이 랜덤 간격으로 추가되고(이 예에서는 2개가 추가됨) 이 막대들 사이에 가로 방향의 선들이 또한 랜덤하게 연결된다.
X=0인 출발점에서 출발하는 사례에 대해서 화살표로 표시한 바와 같이, 아래 방향으로 진행하면서 좌우 방향으로 이동 가능한 통로가 나타나면 방향 전환을 하게 된다.
방향 전환 이후엔 다시 아래 방향으로만 이동하게 되며, 바닥에 도착하면 멈추게 된다.
문제의 X표시에 도착하려면 X=4인 출발점에서 출발해야 하므로 답은 4가 된다. 해당 경로는 별도로 표시하였다.

아래 <그림 2>와 같은 100 x 100 크기의 2차원 배열로 주어진 사다리에 대해서, 지정된 도착점에 대응되는 출발점 X를 반환하는 코드를 작성하라 (‘0’으로 채워진 평면상에 사다리는 연속된 ‘1’로 표현된다. 도착 지점은 '2'로 표현된다).

입력 파일의 첫 번째 줄에는 테스트 케이스의 번호가 주어지며, 바로 다음 줄에 테스트 케이스가 주어진다.

총 10개의 테스트 케이스가 주어진다.
'''

import sys
sys.stdin = open('input.txt','r')

# 반환값은 100행에 위치한 특정 열 번호
# arr[100][idx번호]
# 도착지점은 2
# 먼저 2의 위치를 찾아야하나
# 출발점 x를 반환해야 함
# 그러면, 도착점에서 거슬러 올라간다. 올라가다가
# if 왼쪽 1이면 왼쪽이동, if 오른쪽 1이면 오른쪽이동
# 그리고 다시 왼쪽이동 조건문에서 만약 위에가 1이면 위로 이동 그렇지않고 계속 왼쪽이면 왼쪽이동
# 이걸 반복해주면 출발점 도착가능
# 근데 그러면 알아봐야할 것이, 일단 2가 어디에 위치하고 있는지.
# 2의 위치를 찾고 인접한 값들이 뭔지 찾아야 한다.

for tc in range(1, 11):
    N = int(input())
    arr = [list(map(int,input().split())) for _ in range(100)]
    # 사다리 만들었음
    d_f = [1, -1, 1]    
    # 상, 좌, 우
    # arr[i][j]
    # 위로 갈수 있는지 확인할 때는 i 인덱스, 좌우로 이동 가능에 대해서는 J인덱스 확인

    for i in range(100):
        if arr[99][i] == 2:
            X = i
            # arr[99][X] = 탐색 시작점
    # arr[0][] 에 도착하면 끝나야 하니까
    idx = 99
    ans = 0

    # 출발점이 담길 변수
    # X의 값을 계속 변동시켜줘야 한다.
    # X = 46
    # 한 칸 왼쪽이나 오른쪽으로 이동했을 떄, 그 방향으로 일단 0이 나올때 까지 계속 가야함.
    # 만약 출발점이 0이나 끝값으로 주어진다면

    while True:                 # 만약 왼쪽 1 옆으로 전진 . 만약 오른쪽 1 오른쪽 전진
        if idx == 0:           # 첫 행에 도착했다는 뜻
            ans = X
            break
            # idx값이 0일때, X가 갖는 값은 ?
            # idx가 0이라는건 첫 행에 도착했다는 말
        if (X > 0) and (X < 99) and (arr[idx][X-1]==0) and (arr[idx][X+1]==0):    
            # 현 위치 기준 오른쪽 왼쪽이 없다면 올라가라, X는 0보다 크고, 99보다 작을 경우
            # 그 이상으로 올라가면 인덱스 에러가 발생할 수 있다
            idx -= 1
            continue
        if (X == 0) and (arr[idx][X+1]==0):
            idx -= 1
            continue
        if (X==99) and (arr[idx][X-1]==0):
            idx -= 1
            continue
            # X 값들에 대해서는 처리가 된 것 같다는 생각...
        elif (X>=1) and arr[idx][X-1]==1:                
            # 왼쪽이 1이라면
            while (X>=1) and (arr[idx][X-1] == 1):      # 현 위치 기준 왼쪽이 1이라면 왼쪽으로 이동
                X = X-1
            idx -= 1
            continue
        elif (X<=98) and arr[idx][X+1]== 1:      # 현 위치 기준 오른쪽이 1이라면 오른쪽으로 이동
            while (X<=98) and arr[idx][X+1] == 1:
                X = X+1
            idx -= 1
            continue
        elif (X==0) and arr[idx][X+1] == 1:
            while arr[idx][X+1] == 1:
                X += 1
            idx -= 1
            continue
        elif (X==99) and arr[idx][X-1] == 1:
            while arr[idx][X-1] == 1:
                X -= 1
            idx -= 1
    

    print('#{} {}'.format(tc,ans))